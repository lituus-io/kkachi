// Copyright © 2025 lituus-io <spicyzhug@gmail.com>
// All Rights Reserved.
// Licensed under PolyForm Noncommercial 1.0.0

//! DSPy-Style Declarative Pipeline Example
//!
//! This example demonstrates how to use kkachi's declarative API to build
//! sophisticated LLM pipelines with DSPy-style patterns:
//!
//! - **Declarative Refinement**: Iterative improvement with critics
//! - **Recall/Precision Tuning**: Fine-grained control over output quality
//! - **Candidate Pools**: Post-hoc filtering of multiple candidates
//! - **Chain Pools**: Self-consistency through voting analysis
//! - **Stepwise Improvement**: Visualizing iteration-by-iteration progress

use kkachi::{
    // Declarative API (old recursive API)
    Kkachi,
    // Recall/Precision tuning
    RecallPrecisionMode, PromptTone,
    // Candidate/Chain pools for analysis
    ScoredCandidate, CandidatePool,
    ChainPool,
    // Vector stores and RAG
    HashEmbedder, InMemoryVectorStore, VectorStore,
    // Diff visualization
    diff::{DiffRenderer, DiffStyle, TextDiff},
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    println!("═══════════════════════════════════════════════════════════════════");
    println!("   DSPy-Style Declarative Pipeline with Kkachi");
    println!("═══════════════════════════════════════════════════════════════════\n");

    // Run all examples
    example_1_basic_declarative_api()?;
    example_2_chain_of_thought_pattern()?;
    example_3_candidate_pool_analysis()?;
    example_4_chain_pool_consensus()?;
    example_5_stepwise_improvement()?;
    example_6_full_pipeline().await?;

    println!("\n═══════════════════════════════════════════════════════════════════");
    println!("   All DSPy Examples Complete!");
    println!("═══════════════════════════════════════════════════════════════════");

    Ok(())
}

/// Example 1: Basic Declarative API
fn example_1_basic_declarative_api() -> anyhow::Result<()> {
    println!("╔════════════════════════════════════════════════════════════════╗");
    println!("║  Example 1: Basic Declarative API                              ║");
    println!("╚════════════════════════════════════════════════════════════════╝\n");

    // Simple synchronous usage with closure-based LLM
    let result = Kkachi::refine("question -> answer")
        .domain("math")
        .max_iterations(3)
        .until_score(0.9)
        // Note: min_length and require are part of HeuristicCritic, not RefineBuilder
        .run_sync("What is 15 + 27?", |_prompt, _feedback, iter| {
            Ok(match iter {
                0 => "42".to_string(),
                1 => "15 + 27 = 42".to_string(),
                _ => "The sum of 15 and 27 equals 42.".to_string(),
            })
        })?;

    println!("  Question: What is 15 + 27?");
    println!("  Answer: {}", result.answer);
    println!("  Score: {:.0}%", result.score * 100.0);
    println!("  Iterations: {}", result.iterations);
    println!("  Converged: {}", result.converged);
    println!();

    Ok(())
}

/// Example 2: Chain of Thought Pattern
fn example_2_chain_of_thought_pattern() -> anyhow::Result<()> {
    println!("╔════════════════════════════════════════════════════════════════╗");
    println!("║  Example 2: Chain of Thought Pattern                           ║");
    println!("╚════════════════════════════════════════════════════════════════╝\n");

    // CoT-style responses with step-by-step reasoning
    let responses = vec![
        "25% of 80 = 20",
        "To find 25% of 80: 0.25 * 80 = 20. Therefore, the answer is 20.",
        "Step 1: Convert 25% to decimal: 25/100 = 0.25\nStep 2: Multiply: 0.25 × 80 = 20\nTherefore, 25% of 80 is 20.",
    ];

    let result = Kkachi::refine("question -> reasoning, answer")
        .domain("math_cot")
        .max_iterations(3)
        .until_score(0.95)
        // Note: min_length and require are part of HeuristicCritic, not RefineBuilder
        .run_sync("What is 25% of 80?", |_, _, iter| {
            Ok(responses[iter.min(responses.len() as u32 - 1) as usize].to_string())
        })?;

    println!("  Question: What is 25% of 80?");
    println!("  Response: {}", result.answer.lines().next().unwrap_or(""));
    println!("  Score: {:.0}%", result.score * 100.0);
    println!("  Iterations: {}", result.iterations);
    println!();

    Ok(())
}

/// Example 3: Candidate Pool Analysis (BestOfN style)
fn example_3_candidate_pool_analysis() -> anyhow::Result<()> {
    println!("╔════════════════════════════════════════════════════════════════╗");
    println!("║  Example 3: Candidate Pool Analysis (BestOfN)                  ║");
    println!("╚════════════════════════════════════════════════════════════════╝\n");

    // Simulated candidates with pre-computed scores
    let candidates = vec![
        ("fn parse(s: &str) { s.parse().unwrap() }", 0.2),
        ("fn parse(s: &str) -> i32 { s.parse().unwrap() }", 0.4),
        ("fn parse(s: &str) -> Option<i32> { s.parse().ok() }", 0.6),
        ("/// Parse string\nfn parse(s: &str) -> Option<i32> { s.parse().ok() }", 0.8),
        ("/// Parse safely.\nfn parse(s: &str) -> Result<i32, _> { s.parse() }", 1.0),
    ];

    println!("  Generated {} candidates:\n", candidates.len());
    for (i, (code, score)) in candidates.iter().enumerate() {
        println!("    Candidate {}: score={:.1}", i + 1, score);
        println!("      {}", code.lines().next().unwrap_or(""));
    }

    // Build CandidatePool
    let mut pool = CandidatePool::new();
    for (i, (_, score)) in candidates.iter().enumerate() {
        pool.push(ScoredCandidate::new(*score, i as u8));
    }
    pool.sort_by_score();

    // Statistics
    let stats = pool.stats();
    println!("\n  Pool Statistics:");
    println!("    Count: {}", stats.count);
    println!("    Best: {:.2}", stats.best_score);
    println!("    Mean: {:.2}", stats.mean_score);
    println!("    Std Dev: {:.2}", stats.std_dev);

    // Filter by recall/precision modes
    println!("\n  Filtering by Mode:");
    let modes = [
        ("High Recall (0.6)", RecallPrecisionMode::HighRecall(0.6)),
        ("Balanced (0.8)", RecallPrecisionMode::Balanced),
        ("High Precision (0.9)", RecallPrecisionMode::HighPrecision(0.9)),
    ];

    for (name, mode) in &modes {
        let filtered = pool.filter_by_mode(*mode);
        println!("    {}: {} candidates pass", name, filtered.len());
    }

    // Best candidate
    if let Some(best) = pool.best() {
        println!("\n  Best Candidate:");
        println!("    Score: {:.1}", best.score);
        println!("    Code: {}", candidates[best.index as usize].0.lines().next().unwrap_or(""));
    }

    println!();
    Ok(())
}

/// Example 4: Chain Pool Consensus (MultiChain style)
fn example_4_chain_pool_consensus() -> anyhow::Result<()> {
    println!("╔════════════════════════════════════════════════════════════════╗");
    println!("║  Example 4: Chain Pool Consensus (Self-Consistency)            ║");
    println!("╚════════════════════════════════════════════════════════════════╝\n");

    // Simulated reasoning chains with answers
    let chain_answers = vec![
        "42".to_string(),
        "42".to_string(),
        "41".to_string(),  // Wrong
        "42".to_string(),
        "43".to_string(),  // Wrong
    ];

    println!("  Question: What is 6 × 7?");
    println!("  Running {} reasoning chains...\n", chain_answers.len());

    // Create ChainPool
    let pool = ChainPool::from_answers(
        &chain_answers,
        "42".to_string(),  // Majority answer
        chain_answers.len() as u8,
        100, 50,  // Token counts
    );

    // Show chain results
    println!("  Chain Results:");
    for chain in pool.all_chains() {
        let marker = if chain.agrees_with_majority { "✓" } else { "✗" };
        println!("    Chain {}: {} [{}] (consensus: {:.0}%)",
            chain.index + 1,
            chain.answer,
            marker,
            chain.consensus_score * 100.0
        );
    }

    // Statistics
    let stats = pool.stats();
    println!("\n  Statistics:");
    println!("    Distinct answers: {}", stats.distinct_answers);
    println!("    Agreement ratio: {:.0}%", stats.agreement_ratio * 100.0);
    println!("    Perfect consensus: {}", pool.has_perfect_consensus());

    println!("\n  Selected Answer: {} (by majority vote)", pool.selected_answer);

    // High-confidence chains
    println!("\n  High-confidence chains:");
    let high_conf = pool.filter_by_mode(RecallPrecisionMode::HighPrecision(0.5));
    for chain in high_conf {
        println!("    Chain {}: {}", chain.index + 1, chain.answer);
    }

    println!();
    Ok(())
}

/// Example 5: Stepwise Improvement Visualization
fn example_5_stepwise_improvement() -> anyhow::Result<()> {
    println!("╔════════════════════════════════════════════════════════════════╗");
    println!("║  Example 5: Stepwise Improvement Cycle                         ║");
    println!("╚════════════════════════════════════════════════════════════════╝\n");

    let diff_renderer = DiffRenderer::new().with_style(DiffStyle::Unified);

    // Simple scoring function (mimics ChecklistCritic behavior)
    let score_code = |code: &str| -> (f64, Vec<&str>) {
        let mut score = 0.0;
        let mut issues = Vec::new();

        if code.contains("fn ") { score += 0.2; } else { issues.push("Missing function"); }
        if code.contains("->") { score += 0.2; } else { issues.push("Missing return type"); }
        if code.contains("///") { score += 0.2; } else { issues.push("Missing docs"); }
        if code.contains("Result<") { score += 0.2; } else { issues.push("Missing Result"); }
        if !code.contains("unwrap") { score += 0.2; } else { issues.push("Uses unwrap"); }

        (score, issues)
    };

    println!("  Task: Generate safe file reading function\n");

    // Improvement steps
    let steps = vec![
        "fn read(p: &str) { std::fs::read_to_string(p).unwrap() }",
        "fn read(p: &str) -> String { std::fs::read_to_string(p).unwrap() }",
        "/// Read file\nfn read(p: &str) -> String { std::fs::read_to_string(p).unwrap() }",
        "/// Read file safely.\nfn read(p: &str) -> Result<String, std::io::Error> { std::fs::read_to_string(p) }",
    ];

    let mut prev_code = String::new();
    let mut scores = Vec::new();

    for (iter, code) in steps.iter().enumerate() {
        let (score, issues) = score_code(code);
        scores.push(score);

        // Show diff
        if iter > 0 {
            let diff = TextDiff::new(&prev_code, code);
            println!("  ─── Iteration {} → {} ───", iter - 1, iter);
            println!("{}", diff_renderer.render_text(&diff));
        } else {
            println!("  ─── Iteration {} ───", iter);
            println!("  {}", code.lines().next().unwrap_or(""));
        }

        println!("  Score: {:.0}%{}", score * 100.0,
            if score >= 0.9 { " ✓ Converged" } else { "" });

        if !issues.is_empty() {
            println!("  Issues: {}", issues.join(", "));
        }
        println!();

        prev_code = code.to_string();

        if score >= 0.9 {
            break;
        }
    }

    // Summary
    println!("  ═══ Summary ═══");
    println!("  Score progression: {}", scores.iter()
        .map(|s| format!("{:.0}%", s * 100.0))
        .collect::<Vec<_>>()
        .join(" → "));

    Ok(())
}

/// Example 6: Full DSPy-Style Pipeline
async fn example_6_full_pipeline() -> anyhow::Result<()> {
    println!("╔════════════════════════════════════════════════════════════════╗");
    println!("║  Example 6: Full DSPy-Style Pipeline                           ║");
    println!("╚════════════════════════════════════════════════════════════════╝\n");

    // Step 1: RAG Vector Store
    println!("  Step 1: Initialize RAG Vector Store");
    let embedder = HashEmbedder::new(64);
    let mut store = InMemoryVectorStore::new(embedder);

    let examples = vec![
        ("rust:option", "fn safe_div(a: i32, b: i32) -> Option<i32> { if b == 0 { None } else { Some(a/b) } }"),
        ("rust:result", "fn parse_int(s: &str) -> Result<i32, _> { s.parse() }"),
        ("rust:iter", "fn sum_evens(v: &[i32]) -> i32 { v.iter().filter(|n| *n % 2 == 0).sum() }"),
    ];

    for (id, content) in &examples {
        store.add(*id, *content);
    }
    println!("    Loaded {} examples", examples.len());

    // Step 2: RAG Retrieval
    println!("\n  Step 2: RAG Retrieval");
    let query = "safe division function";
    let results = store.search_text(query, 2);
    println!("    Query: \"{}\"", query);
    for r in &results {
        println!("    Retrieved: {} (score: {:.3})", r.id, r.score);
    }

    // Step 3: Configure Pipeline
    println!("\n  Step 3: Configure Pipeline");
    let mode = RecallPrecisionMode::Balanced;
    let tone = PromptTone::Balanced;
    println!("    Mode: {:?} (threshold: {:.1})", mode, mode.threshold());
    println!("    Tone: {:?}", tone);

    // Step 4: Execute with Refinement
    println!("\n  Step 4: Execute Refinement");

    let responses = vec![
        "fn divide(a: i32, b: i32) -> i32 { a / b }",
        "fn divide(a: i32, b: i32) -> Option<i32> { Some(a / b) }",
        "fn divide(a: i32, b: i32) -> Option<i32> { if b == 0 { None } else { Some(a/b) } }",
        "/// Safe division.\nfn divide(a: i32, b: i32) -> Option<i32> { if b == 0 { None } else { Some(a/b) } }",
    ];

    let result = Kkachi::refine("task -> code")
        .domain("rust_safe")
        .max_iterations(4)
        .until_score(mode.threshold())
        // Note: min_length, require, forbid are part of HeuristicCritic, not RefineBuilder
        .on_iteration(|iter, score, _feedback| {
            println!("    Iteration {}: score={:.0}%", iter, score * 100.0);
        })
        .run_sync("Write safe integer division", |_, _, iter| {
            Ok(responses[iter.min(responses.len() as u32 - 1) as usize].to_string())
        })?;

    // Step 5: Results
    println!("\n  Step 5: Results");
    println!("    Score: {:.0}%", result.score * 100.0);
    println!("    Iterations: {}", result.iterations);
    println!("    Converged: {}", result.converged);

    println!("\n  Generated Code:");
    println!("    {}", result.answer.replace('\n', "\n    "));

    // Step 6: Store if successful
    if result.score >= mode.threshold() {
        println!("\n  Step 6: Store in RAG");
        let new_id = format!("rust:safe_div_{}", result.iterations);
        store.add(&new_id, &result.answer);
        println!("    Stored as: {}", new_id);
        println!("    Total examples: {}", store.len());
    }

    println!();
    Ok(())
}
